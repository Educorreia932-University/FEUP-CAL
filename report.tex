\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=0.8in]{geometry} 
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{amsmath}
\usepackage[noend]{algpseudocode}

\title{\textbf{Tour Mate App}}
\author{
    Alexandre Abreu\\
    \texttt{up201800168@fe.up.pt}
    \and
    Eduardo Correia\\
    \texttt{up201806433@fe.up.pt}
    \and
    Juliane Marubayashi\\
    \texttt{up201800175@fe.up.pt}
}

\renewcommand{\today}{\ifcase \month \or January\or February\or March\or %
April\or May \or June\or July\or August\or September\or October\or November\or %
December\fi, \number \year}
\date{
    Faculdade de Engenharia da Universidade do Porto\\
    \today
}

\begin{document}

\maketitle

\section*{Keywords}

Tourism, Graph Theory, Network Modelling

\section*{Abstraction} 
    The goal of this project is to build the \textit{TourMateApp} application. \par 
    This hypothetical application's purpose would be to generate adaptable urban tourist routes, according to the personal preferences of its user.\par

\section*{Introduction}
\subsection*{Problem Description}
    The problem discussed in this paper is how to evaluate the best tourist path to a client that is in a specific place and has limited time to spend, taking into account his preferences.\par
    We must take into account the time spend in commutations and the expected time of visits.
    For this paper, we used the Porto city as a reference model to work on.

\section*{Model Formulation}
\subsection*{Edge Weight}
    The maximum speed and the distance to travel along an edge are used to calculate the cost of moving between two nodes, assuming there will be no interaction with other vehicles or people.
    
\subsection*{Input Data}

To initially obtain the map data we needed to apply the algorithm, we resort to 
OSMnx \cite{OSMnx}, a Python library that retrieves, models, analyzes, and visualizes street networks and other spatial data from OpenStreetMaps \cite{OpenStreetMaps}. \par
On that way we can easily obtain a visual representation of streets and locations much like a graph - in which the crossings/POIs would be vertexes and the streets would be edges - and export it to a file our algorithm could parse. \par
Furthermore, the user would inform about its preferences, according to its trip purpose (recreational, work...), such as the list of POIs to visit, the maximum total time available to spend, the type of circuit (by foot, bicycle, car, public transportation...).

\subsection*{Output Data}
    \subsubsection*{Output data available for the user}
    \begin{itemize}
        \item The path to pass by in order to achieve the points of interest as the path line shown on the map.
        \item Name of the streets and directions needed to be followed in respective order.
        \item The total time to be spent by the tourist, including visiting the POIs, and in the way to get to the places.
        \item The total distance to go. 
    \end{itemize}
    
    \subsubsection*{Output data after loading files}
    After reading the \textit{.csv} file with edges and nodes information, a \textit{Dense Direct Graph} will be built. The \textit{.csv} file (obtained with OMSnx library \cite{OSMnx} and cleaned with Pandas \cite{Pandas}) stores information about the edges and nodes with the followed fields: \newline 
    \subsubsection*{Nodes}
        The nodes \textit{.csv} file is a simple table of one column with all the nodes in the graph identified by it's id. 
    \subsubsection*{Edges}
    \begin{itemize}
        \item Source: The id of the source node. 
        \item Target: The id of the target node. 
        \item OSM id: the id of the node in the Open Street Map. 
        \item Name: name of the street in which the node belongs. 
        \item Oneway: if the street is just one way.
        \item Maxspeed: the maxspeed of the road.
    \end{itemize}
    
    With this information, a graph $G(V,E)$ will be built with $V$ as vertexes and $E$ as edges, where:
    \subsubsection*{Vertexes}
    \begin{itemize}
        \item $Adj$: adjacent list, $Adj \subseteq E$, where $\exists \lambda(i,j)$  $$
    \end{itemize} 
    
    \subsubsection*{Edges} 
    
        
\subsection*{Decision Variables}

\subsection*{Objective Function}

Minimize total time spend in commuting, total traveled time. \par
Maximize number of points of interest visited.

\subsection*{Decision Variables}

\subsection*{Constraints}

\section*{Identification of Supported Cases}
    Considering the initial options given in the main menu of the application, the supported cases includes: 
    \begin{itemize}
        \item Different types of locomotion: bus, on foot and car.
        \item 
    \end{itemize}
\section*{Solution Description}
\subsection*{Data Treatment}

\subsection*{Algorithms}
    The main algorithm to be used in the application is the \textit{Floyd Warshall} \cite{IntroductionToAlgorithms}. \par
    
    \begin{algorithm}[h]
    \caption{Floyd Warshall}\label{euclid}
    \begin{algorithmic}[1]
    \Procedure{Shortest Path}{}

    \EndProcedure
    \end{algorithmic}
    \end{algorithm}

    This algorithm considers the intermediate nodes to find and store all the shortest \b{distance} between nodes $i$ and $j$ with $k$ as intermediate vertex ($i \rightarrow k \rightarrow j$, which can simply described by the recursion formula: 
    
    \begin{equation} 
      d_{ij}^{(k)} =
        \begin{cases}
          w_{ij} & \text{if k = 0}\\
          min(d_{ij}^{k-1}, d_{ik}^{k-1} + d_{ki}^{k-1}) & \text{if } k\>= 1\\
        \end{cases}       
    \end{equation}
    
    Besides the $O(|V^3|)$ complexity, this is a good approach for dense graphs like city networks.
    However, the \textit{Floyd Warshall} algorithm doesn't store the path between nodes. To do so, we can consider a new matrix called $\Pi$. \par
    For each $d_{ij}^{k}$ element in the matrix of shortest path $D^k$ the matrix $\Pi$ will contain the respective shortest path for the pair of nodes $i$ and $j$. \par
    Formally, each element of $\Pi$ can be described as it follows for $k>1$: 
    
    \begin{equation} 
      \pi_{ij}^{(k)} =
        \begin{cases}
          \pi_{ij}^{k-1} & \text{if } d_{ij}^{k-1} <= d_{ik}^{k-1} + d_{kj}^{k-1} \\
          \pi_{kj}^{k-1} & \text{if } d_{ij}^{k-1} > d_{ik}^{k-1} + d_{kj}^{k-1}\\
        \end{cases}       
    \end{equation}
    
    For $k = 0$ the definition will be: 
    
    \begin{equation} 
      \pi_{ij}^{(0)} =
        \begin{cases}
          NIL & \text{if } w = \inf \vee \text{ i = j}\\
          i & \text{if } i \neq j \wedge w < \inf\\
        \end{cases}      
    \end{equation}
    
    For completing the algorithm analysis, the spacial complexity for this algorithm should be $O(v^2)$. \newline 
    In order to make the waiting time less significant, improvements to this algorithm will be considered. 

\subsection*{Data Structures}

Directed Graph D(V, E)
Vertexes V
Edges E

\section*{Conclusion} 

\begin{thebibliography}{9}

\bibitem{IntroductionToAlgorithms}
Cormen, Thomas H., and Thomas H. Cormen. 2001. \textit{Introduction to algorithms}. Cambridge, Mass: MIT Press.

\bibitem{OSMnx} 
Boeing, Geoff, \textit{OSMNnx}, Github repository, https://github.com/gboeing/osmnx

\bibitem{OpenStreetMaps} 
\textit{Open Street Maps}, https://www.openstreetmap.org/

\bibitem{Pandas}
\textit{Pandas}, https://github.com/pandas-dev/pandas

\end{thebibliography}

\end{document}
